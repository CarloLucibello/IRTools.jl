var documenterSearchIndex = {"docs":
[{"location":"#IRTools-1","page":"Home","title":"IRTools","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"IRTools provides an IR format with several aims. The idea is to be:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Expressive enough to represent all parts of Julia's IR pipeline, from lowered code to typed SSA IR;\nEasy to manipulate, like an AST, so that people can do powerful macro-like transformations of code;\nsafe â€“ so no segfaults if you misplace an variable somewhere.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that before even attempting to understand IRTools, you should have a good handle on Julia's metaprogramming and macros.","category":"page"},{"location":"#Reading-the-IR-1","page":"Home","title":"Reading the IR","text":"","category":"section"},{"location":"#IR-Basics-1","page":"Home","title":"IR Basics","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It's easiest to understand the IRTools IR by seeing some examples. We provide the macro @code_ir which behaves much like @code_lowered.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using IRTools\n\njulia> f(x) = x+x\nf (generic function with 1 method)\n\njulia> @code_ir f(1)\n1:\n  %1 = _2 + _2\n  return %1","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First things first. Arguments are numbered, and the first argument represents the function f itself, so x is presented in the IR as _2. Intermediate variables (%1, %2, %3 ...) are also numbered. IR will usually have a lot of these, which is why numbers make more sense than names.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The main reason that there are a lot of intermediates is that, in IR, we only allow one function call per line. You can see how a nested Julia expression becomes a sequence of single instructions, kind of like an assembly language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> f(x) = 3x*x + 2x + 1\nf (generic function with 1 method)\n\njulia> @code_ir f(1)\n1:\n  %1 = 3 * _2\n  %2 = %1 * _2\n  %3 = 2 * _2\n  %4 = %2 + %3 + 1\n  return %4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"While this looks noisy and is at first a little hard to read, it's usually a helpful thing to do. IR is largely designed to be read by programs, rather than by humans, where it's usually easier to look at one instruction at a time.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Beyond that, this is essentially just very verbosely-written Julia code.","category":"page"},{"location":"#Control-Flow-1","page":"Home","title":"Control Flow","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The most significant difference between IR and Expr is how control flow is handled. There are no such thing as nested if statements, while loops and so on in IR, only branches.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> f(x) = x > 0 ? x : 0\nf (generic function with 1 method)\n\njulia> @code_ir f(1)\n1:\n  %1 = _2 > 0\n  br 3 unless %1\n2:\n  return _2\n3:\n  return 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The block labels 1:, 2: etc and the branch br 3 unless %1 can be thought of as a version of @label and @goto. In this case the branch is conditional on the test %1 = x > 0; if that's true we'll skip the branch, move on to the label 2 and return x.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"IR is composed of a series of basic blocks that jump between each other like this. A basic block always starts with a label and ends with (optional) branches. No branches can appear in the middle of a basic block; that would just divide the block in two. Any structured control flow, however complex, can be turned into a series of blocks like this.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here's a more interesting example.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> function f(x)\n         if x < 0\n           x = -x\n         end\n         return x\n       end\nf (generic function with 1 method)\n\njulia> @code_ir f(1)\n1:\n  %1 = _2 < 0\n  br 3 (_2) unless %1\n2:\n  %2 = -_2\n  br 3 (%2)\n3: (%3)\n  return %3","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Basic blocks are actually like mini-functions, and they accept a series of arguments. In this case block 3 takes an argument called %3 that tells it what to return. If you follow the branches as if they were function calls, you'll see that this IR behaves the same the same as the code we wrote down.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Why not just write this as _2 = - _2? It's important to understand that variables in SSA-form IR are immutable, in the same sense that variables in functional languages are. For this reason you'll never see a statement like %2 = %2 + 1. This again makes analysing IR programmatically a lot easier, because when code uses %2 you know exactly which definition that refers to.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Loops work this way too: they are visible in the IR by branches that jump backwards, i.e. the br 2 here.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> function pow(x, n)\n         r = 1\n         while n > 0\n           n -= 1\n           r *= x\n         end\n         return r\n       end\npow (generic function with 1 method)\n\njulia> @code_ir pow(1, 1)\n1:\n  %1 = nothing\n  br 2 (1, _3)\n2: (%2, %3)\n  %4 = %3 > 0\n  br 4 unless %4\n3:\n  %5 = %3 - 1\n  %6 = %2 * _2\n  br 2 (%6, %5)\n4:\n  return %2","category":"page"},{"location":"#Manipulating-IR-1","page":"Home","title":"Manipulating IR","text":"","category":"section"},{"location":"#Statements-1","page":"Home","title":"Statements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It's easy to get started by creating an empty fragment of IR.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using IRTools: IR, Argument, var\n\njulia> ir = IR()\n1:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can push new statements into the IR.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> x = arg(2)\n_2\n\njulia> x2 = push!(ir, :($x*$x))\n%1\n\njulia> ir\n1:\n  %1 = _2 * _2","category":"page"},{"location":"#","page":"Home","title":"Home","text":"push! returns a variable name that we can reuse later on.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> push!(ir, :(3*$x2 + 2*$x + 1))\n%5\n\njulia> ir\n1:\n  %1 = _2 * _2\n  %2 = 3 * %1\n  %3 = 2 * _2\n  %4 = %2 + %3 + 1","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The IR can be viewed as a mapping from variables to statements, and indexing and iteration are consistent with that.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ir[var(2)]\nIRTools.Statement(:(3 * %1), Any, 0)\n\njulia> collect(ir)\n4-element Array{Any,1}:\n (%1, IRTools.Statement(:(_2 * _2), Any, 0))\n (%2, IRTools.Statement(:(3 * %1), Any, 0))\n (%3, IRTools.Statement(:(2 * _2), Any, 0))\n (%4, IRTools.Statement(:(%2 + %3 + 1), Any, 0))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Statement consists of an expression, a type (usually Any unless you're explicitly working with typed IR) and a line number. If you work directly with expressions IRTools will automatically wrap them with Statement(x).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are a few other functions that do obvious things: pushfirst!, insert!, insertafter!, and delete!.","category":"page"},{"location":"#Blocks-1","page":"Home","title":"Blocks","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In most cases you won't build IR from scratch, but will work from a fragment from an existing function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ir = @code_ir pow(1, 1)\n1:\n  %1 = nothing\n  br 2 (1, _3)\n2: (%2, %3)\n  %4 = %3 > 0\n  br 4 unless %4\n3:\n  %5 = %3 - 1\n  %6 = %2 * _2\n  br 2 (%6, %5)\n4:\n  return %2","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can work with a block at a time with block(ir, n) (all of them with blocks(ir)). Blocks similarly support functions like push!.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using IRTools: block\n\njulia> block(ir, 2)\n2: (%2, %3)\n  %4 = %3 > 0\n  br 4 unless %4","category":"page"},{"location":"#IR-Internals-1","page":"Home","title":"IR Internals","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Internally the IR data structure is quite simple, and it's worth looking at the source code for more details. Each IR fragment is essentially a list of basic blocks.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ir = @code_ir pow(1, 1);\n\njulia> ir.blocks[1]\nIRTools.BasicBlock(IRTools.Statement[Statement(nothing, Nothing, 0)], IRTools.Variable[], IRTools.Branch[br 2 (1, _3)])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Each block is a list of statements, argument names and branches.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that no variable names like %2 are set here. This is defined by a mapping at the IR level:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ir.defs\n6-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (-1, -1)\n (-1, -1)\n (2, 3)\n (3, 1)\n (3, 2)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SSA values are looked up from this table, in order, so %4 refers to statement 3 of block 2 and so on. Values listed as (-1, -1) have been deleted.","category":"page"}]
}
